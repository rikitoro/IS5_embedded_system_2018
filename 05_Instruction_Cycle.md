# CDECv標準命令の命令サイクル

CDECvでは、命令は1ステップ(1クロック)で行われるのではなく、複数のステップを経て実行されます。
一つの命令を実行するのに必要なすべてのステップは命令サイクル(Instruction Cycle)と呼ばれます。
この命令サイクルは、命令をメモリから取り出しどの命令を実行するのかを確定するまでのフェッチサイクル(Fetch Cycle)と、取り出した命令を実際に実行するまでの実行サイクル(Execute Cycle)とに分けられます。

CDECvの標準命令は図5.1に示す命令サイクルで行われます。
F0からF2はフェッチサイクルで、それ以降は実行サイクルです。
フェッチサイクルで行う処理は命令によらず同じですが、実行サイクルは命令によって行う処理が異なります。
そのため、命令の種類により、フェッチサイクルの最後のステップF2から実行サイクルへは分岐が生じます。
図5.1中の各ステップの名前とその意味を、表5.1に示します。

![CDECv標準命令の命令サイクル](./assets/instruction_cycle.png "CDECv標準命令の命令サイクル")

<図5.1 CDECv標準命令の命令サイクル>

<表5.1 CDECv標準命令の命令サイクルの各ステップ名>

| ステップ名 | 意味          | 該当する命令 |
|-----|---------------------|-|
| Fn  | フェッチサイクル  | |
| MVn | レジスタ間データ転送命令 | MOV |
| P2n | 2オペランド命令 | ADD, ADC, SUB, SBB, AND, OR, EOR |
| P1n | 1オペランド命令 | INC, DEC, NOT |
| LDn | ロード命令 | LD |
| STn | ストア命令               | ST |
| JPn | 無条件分岐命令 | JMP |
| JCn | 条件付き分岐命令    | JS, JZ, JC |

以下ではまず、フェッチサイクルの各ステップで行う処理について説明します。
その後、それぞれの実行サイクルの各ステップで行う処理について説明します。


## フェッチサイクル (F0-F2)

フェッチサイクルでは、これから実行しようとする命令の機械語コードをメモリから取得します。


フェッチサイクルの各ステップで行う処理を表5.2に示します。
表5.2の各行は、各ステップにおいて、Xbusを介して行うデータ転送、メモリ操作、AULに関連した操作を示しています。
表中の lhs -> reg という表記は左辺のデータlhsをレジスタregへ転送することを表します。
例えば PC -> MAR はプログラムカウンタPCに格納されたデータをMARに転送することを表し、 PC + 1 -> R は(ALUにおいて)PCに1を加えた結果をRレジスタへ転送することを表します。

<表5.2 フェッチサイクルで行う処理>

|ステップ| Xbus | Memory | ALU |
|---|---|---|---|
| F0 | PC -> MAR |                | PC + 1 -> R |
| F1 | R -> PC   | MEM[MAR] -> RD |             |
| F2 | RD -> I   |                |             |

F0では、PCが指し示すメモリのアドレスに格納されたデータ(命令の機械語コード)にアクセスするため、PCの内容をMARに転送します。
同時にALUではPCをインクリメントした結果をRレジスタへ格納します。

F1ではRレジスタの内容をPCに書き込むことで、結果的にPCがインクリメントされます。これにより次の命令の取得に備えます。
メモリでは読出し操作を行います。MARが確定してからメモリの内容を読みだすまでに1クロック必要であったことを注意してください。
この時点で(インクリメントされる前の)PCが指し示すアドレスに格納されていた命令の機械語コードがRDに出力されます。

F2ではRDの値、すなわち命令の機械語コードを命令レジスタIへ転送します。
Iレジスタの内容は制御部へ送られるため、この時点で制御部はこれから実行する命令を知ることができます。

## 実行サイクル


### レジスタ間データ転送命令の実行サイクル
