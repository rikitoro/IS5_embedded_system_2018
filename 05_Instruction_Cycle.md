# CDECv標準命令の命令サイクル

CDECvでは、命令は1ステップ(1クロック)で行われるのではなく、複数のステップを経て実行されます。
一つの命令を実行するのに必要なすべてのステップは命令サイクル(Instruction Cycle)と呼ばれます。
この命令サイクルは、命令をメモリから取り出しどの命令を実行するのかを確定するまでのフェッチサイクル(Fetch Cycle)と、取り出した命令を実際に実行するまでの実行サイクル(Execute Cycle)とに分けられます。

CDECvの標準命令は図5.1に示す命令サイクルで行われます。
F0からF2はフェッチサイクルで、それ以降は実行サイクルです。
フェッチサイクルで行う処理は命令によらず同じですが、実行サイクルは命令によって行う処理が異なります。
そのため、命令の種類により、フェッチサイクルの最後のステップF2から実行サイクルへは分岐が生じます。
図5.1中の各ステップの名前とその意味を、表5.1に示します。

![CDECv標準命令の命令サイクル](./assets/instruction_cycle.png "CDECv標準命令の命令サイクル")

<図5.1 CDECv標準命令の命令サイクル>

<表5.1 CDECv標準命令の命令サイクルの各ステップ名>

| ステップ名 | 意味          | 該当する命令 |
|-----|---------------------|-|
| Fn  | フェッチサイクル  | |
| MVn | レジスタ間データ転送命令 | MOV |
| P2n | 2オペランド命令 | ADD, ADC, SUB, SBB, AND, OR, EOR |
| P1n | 1オペランド命令 | INC, DEC, NOT |
| LDn | ロード命令 | LD |
| STn | ストア命令               | ST |
| JPn | 無条件分岐命令 | JMP |
| JCn | 条件付き分岐命令    | JS, JZ, JC |

以下ではまず、フェッチサイクルの各ステップで行う処理について説明します。
その後、それぞれの実行サイクルの各ステップで行う処理について説明します。


## フェッチサイクル (F0-F2)

フェッチサイクルでは、これから実行しようとする命令の機械語コードをメモリから取得します。

フェッチサイクルの各ステップで行う処理を表5.2に示します。
表5.2の各行は、各ステップにおいて、Xbusを介して行うデータ転送、メモリ操作、AULに関連した操作を示しています。
表中の lhs -> reg という表記は左辺のデータlhsをレジスタregへ転送することを表します。
例えば PC -> MAR はプログラムカウンタPCに格納されたデータをMARに転送することを表し、 PC + 1 -> R は(ALUにおいて)PCに1を加えた結果をRレジスタへ転送することを表します。

<表5.2 フェッチサイクルで行う処理>

|ステップ| Xbus | Memory | ALU |
|---|---|---|---|
| F0 | PC -> MAR |                | PC + 1 -> R |
| F1 | R -> PC   | MEM[MAR] -> RD |             |
| F2 | RD -> I   |                |             |

F0では、PCが指し示すメモリのアドレスに格納されたデータ(命令の機械語コード)にアクセスするため、PCの内容をMARに転送します。
同時にALUではPCをインクリメントした結果をRレジスタへ格納します。

F1ではRレジスタの内容をPCに書き込むことで、結果的にPCがインクリメントされます。これにより次の命令の取得に備えます。
メモリでは読出し操作を行います。表中 MEM[MAR] -> RD はMARで指定されたアドレスに格納されたデータをRDへ出力することを意味しています。
MARが確定してからメモリの内容を読みだすまでに1クロック必要であったことを注意してください。
F0でMARが確定され、1クロック後のF1でメモリの内容がRDに出力されます。
この時点で(インクリメントされる前の)PCが指し示すアドレスに格納されていた命令の機械語コードがRDに出力されていることになります。

F2ではRDの値、すなわち命令の機械語コードを命令レジスタIへ転送します。
Iレジスタの内容は制御部へ送られるため、この時点で制御部はこれから実行する命令を知ることができます。


## 実行サイクル

上記で説明したフェッチサイクルは命令によらず同じ処理を行います。
フェッチサイクルが終了すると、取得した命令に応じた実行サイクルに移ります。
実行サイクルが終了した時点で1つの命令が実行されたことになります。
実行サイクルの最後のステップが終わると、フェッチサイクルの最初のステップF0へ戻り、次の命令の取得が行われます。

以下では命令の種類ごとにそれぞれの命令サイクルでどのような処理を行うかを説明します。


### レジスタ間データ転送命令の実行サイクル (MV0)

レジスタ間データ転送命令 `MOV sreg, dreg` の実行サイクルで行われる処理を表5.2に示します。

<表5.3 `MOV sreg, dreg` の実行サイクルで行う処理>

|ステップ| Xbus | Memory | ALU |
|---|---|---|---|
| MV0 | sreg -> dreg |  |  |

実行サイクルは MV0 のみです。
Xbusを介して転送元の汎用レジスタ sreg から転送先の汎用レジスタ dreg へデータ転送が行われます。
これで、MOV 命令は終了します。


### 2オペランド命令の実行サイクル (P20-P22)

2オペランド命令として `ADD reg` を例にして、実行サイクルで行われる処理を説明します(表5.4)。
 この命令はAレジスタと汎用レジスタregを加算しその結果をAレジスタへ格納します(A + reg -> A)。

<表5.4  `ADD reg` の実行サイクルで行う処理>

|ステップ| Xbus | Memory | ALU |
|---|---|---|---|
| P20 | reg -> T | | |
| P21 | A -> A   | | A + T -> R, Flag(A + T) -> FLG |
| P22 | R -> A   | | |

P20では被加算数となるregのデータをTレジスタへ転送します。

P20では加算数となるAレジスタのデータをXbusへ出力するため、Aレジスタから自分自身(Aレジスタへの)データ転送を行います。
ALUにおいてはXbusに出力されたAレジスタの値と、Tレジスタの値を加算し、その演算結果をRレジスタへ転送します。
同時に、演算結果によって生じたフラグ信号(S, Z, Cy)をフラグレジスタFLGへ格納します。(表中の Flag(A + T) -> FLG は A + T の演算によって生じたフラグ信号をFLGへ転送することを表します)

最後のステップであるP22では、Rレジスタに保持されている演算結果をAレジスタに転送し、ADD命令が終了します。


### 1オペランド命令の実行サイクル (P10-P11)

1オペランド命令として `INC reg` を例にして、実行サイクルで行われる処理を説明します(表5.5)。
この命令は汎用レジスタregの値を1増加させます(reg + 1 -> reg)。


<表5.5  `INC reg` の実行サイクルで行う処理>

|ステップ| Xbus | Memory | ALU |
|---|---|---|---|
| P10 | reg -> reg   | | reg + 1 -> R, Flag(reg + 1) -> FLG |
| P11 | R -> reg     | | |


P10では、汎用レジスタregから自身へのデータ転送によりXbusへregの値を出力し、ALUにおいて reg + 1 を計算します。
その演算結果をRレジスタ、フラグ信号をFLGへ格納します。

最後のステップであるP11では、演算結果が保持されているRレジスタから汎用regへデータが転送され、INC命令が終了します。


### ロード命令の実行サイクル (LD0-LD4)

ロード命令 `LD adrs, dreg` の実行サイクルで行われる処理を説明します(表5.6)。
この命令は adrs で指定されるアドレスに格納されたメモリのデータを汎用レジスタ dreg へ転送します。

|ステップ| Xbus | Memory | ALU |
|---|---|---|---|
| LD0 | PC -> MAR  |                | PC + 1 -> R |
| LD1 | R -> reg   | MEM[MAR] -> RD | |
| LD2 | RD -> MAR  |                | |
| LD3 |            | MEM[MAR] -> RD | |
| LD4 | RD -> dreg |                | |


### ストア命令の実行サイクル (LD0-LD4)

ストア命令 `ST sreg, adrs` の実行サイクルで行われる処理を説明します(表5.6)。

|ステップ| Xbus | Memory | ALU |
|---|---|---|---|
| ST0 | PC -> MAR   |                 | PC + 1 -> R |
| ST1 | R -> reg    | MEM[MAR] -> RD  | |
| ST2 | RD -> MAR   |                 | |
| ST3 | sreg -> WDR |                 | |
| ST4 |             | WDR -> MEM[MAR] | |


## 無条件分岐命令の実行サイクル (JP0-JP2)

無条件分岐命令 `JMP adrs` の実行サイクルで行われる処理を説明します(表5.6)。

|ステップ| Xbus | Memory | ALU |
|---|---|---|---|
| JP0 | PC -> MAR   |                 | |
| JP1 |             | MEM[MAR] -> RD  | |
| JP2 | RD -> PC    |                 | |


## 条件付き分岐命令の実行サイクル (JP0-JP2)


|ステップ| Xbus | Memory | ALU |
|---|---|---|---|
| JC0 | PC -> MAR   |                 | PC + 1 -> R |
| JC1 | R -> PC     | MEM[MAR] -> RD  | |
| JC2 | RD -> PC (S == 1の場合) |     | |
